---
title: "Web World Models"
arxiv_id: "2512.23676"
authors:
  - "Jichen Feng"
  - "Yifan Zhang"
  - "Chenggong Zhang"
  - "Yifu Lu"
  - "Shilong Liu"
  - "Mengdi Wang"
published: "2025-12-29"
updated: "2025-12-29"
categories:
  - "cs.AI"
  - "cs.CL"
  - "cs.CV"
url: "https://arxiv.org/abs/2512.23676"
pdf: "https://arxiv.org/pdf/2512.23676.pdf"
converted_date: "2026-01-08"
translated: "2026-01-09"
language: "ko"
---

# Web World Models

## 저자

**Jichen Feng**[^fn-star](#fn-star)[^aff-1](#aff-1)[^aff-3](#aff-3), **Yifan Zhang**[^fn-star](#fn-star)[^aff-1](#aff-1), **Chenggong Zhang**[^fn-star](#fn-star)[^aff-2](#aff-2), **Yifu Lu**[^fn-star](#fn-star)[^aff-1](#aff-1), **Shilong Liu**[^aff-1](#aff-1)[^fn-dagger](#fn-dagger), **Mengdi Wang**[^aff-1](#aff-1)[^fn-dagger](#fn-dagger)

## 소속

<a id="aff-1"></a>**[^1]** Princeton University

<a id="aff-2"></a>**[^2]** University of California, Los Angeles

<a id="aff-3"></a>**[^3]** University of Pennsylvania

## 각주

<a id="fn-star"></a>**[^∗]** 동등 기여

<a id="fn-dagger"></a>**[^†]** 교신 저자

**프로젝트 페이지**: [https://princeton-ai2-lab.github.io/Web-World-Models/](https://princeton-ai2-lab.github.io/Web-World-Models/)

---

## 초록

언어 agent는 점점 더 행동하고, 기억하고, 학습할 수 있는 persistent world를 필요로 한다. 기존 접근법은 두 가지 극단에 위치한다: 기존 web framework는 database에 의해 뒷받침되는 신뢰할 수 있지만 고정된 context를 제공하고, 완전한 generative world model은 무제한 환경을 목표로 하지만 world가 주로 generation을 통해 구성되어 고정된 deterministic global framework를 유지하기 어렵고 controllability가 감소한다. 본 연구에서 우리는 Web World Model (WWM)을 소개한다. 이는 world state와 "physics"가 logical consistency를 보장하기 위해 일반적인 web code로 구현되고, large language model이 이 structured latent state 위에서 context, narrative, 그리고 high-level decision을 생성하는 중간 지점이다. 우리는 실제 지리에 기반한 무한한 travel atlas, 가상의 galaxy explorer, web-scale encyclopedic 및 narrative world, 그리고 simulation 및 game-like 환경을 포함하는 일련의 WWM을 realistic web stack 위에 구축한다. 이러한 시스템들을 통해 우리는 WWM을 위한 실용적인 design principle을 도출한다: code-defined rule과 model-driven imagination의 분리, latent state를 typed web interface로 표현, 그리고 deterministic generation을 활용하여 unlimited but structured exploration 달성. 우리의 결과는 web stack 자체가 world model을 위한 scalable substrate로 기능할 수 있으며, controllable하면서도 open-ended 환경을 가능하게 함을 시사한다.

---

**Figure 1**: *왼쪽*: 기존 Web Framework는 database에 context를 고정하여 scalability를 제한한다. *중앙*: Web World Model (본 연구)은 logic과 content를 분리하여 무거운 data storage 없이 code-based physics layer 위에서 LLM을 통해 unlimited context를 생성한다. *오른쪽*: 완전한 generative world model은 unlimited context와 풍부한 video/3D content를 생성할 수 있지만, world가 주로 generation을 통해 구성될 때 고정된 deterministic global framework를 유지하기 어렵고 controllability가 감소한다.

![Figure 1](images/figure_1.png)

## 1 서론

현대의 language agent는 점점 더 행동하고, 기억하고, 성장할 수 있는 persistent 환경을 필요로 한다. 오늘날 대부분의 실용적인 시스템은 두 극단 중 하나에 위치한다(Figure 1). 한쪽에서는 기존 web framework가 고정된 context로 작동한다: application state는 database에 저장되고 수작업으로 만든 endpoint를 통해 노출된다. 이 설계는 신뢰성, 강력한 engineering tooling, 그리고 명확한 security boundary를 제공하지만, agent가 거주할 수 있는 world는 궁극적으로 개발자가 미리 예상한 schema에 의해 제한된다. 다른 쪽에서는 general world model이 model의 latent space에서 직접 환경을 생성하려 시도하며, 원칙적으로 unlimited context와 임의의 환경 유형을 지원한다. 그러나 이러한 fully generative world는 control하기 어렵고, debug하기 어려우며, scale하기에 비용이 많이 들고, 장기 실행 application에 필요한 structural guarantee가 부족한 경우가 많다. 결과적으로 fixed-context web application과 unconstrained world model 사이에 누락된 중간 지점이 존재한다.

우리는 Web World Model (WWM)의 개념으로 이 격차를 메우고자 한다. Web World Model은 state와 'physics'가 일반적인 web code(예: TypeScript module, HTTP handler, database schema)에 의해 정의되고, large language model이 이 structured latent state 위에서 context와 narrative를 생성하는 world이다. 이 관점에서 code는 어떤 종류의 entity가 존재하는지, 어떻게 상호작용하는지, 어떤 action이 가능한지를 명시하고; model은 이러한 entity를 description, story, 또는 task-specific reasoning으로 풍부하게 하기 위해 호출된다. 따라서 WWM은 web framework의 controllability, observability, tooling을 계승하면서도 language model을 사용하여 필요에 따라 새로운 content를 synthesize함으로써 사실상 unlimited state space로 procedurally 확장할 수 있다. 고정된 web system과 비교하여 WWM은 작고 정적인 context에 구속되지 않으며; fully generative world model과 비교하여 표준 web infrastructure를 사용하여 test, version, deploy할 수 있는 programmable substrate를 제공한다.

Figure 2 본 연구에서 소개하는 일련의 Web World Model의 예시. 세부 사항은 Section 3에서 제시된다.

![Figure 2](images/figure_2.png)

이 아이디어를 구체화하기 위해 우리는 통합된 web technology stack 위에서 일련의 Web World Model을 구현한다. 이 시스템들은 광범위한 domain을 포괄한다. Infinite Travel Atlas는 실제 지구를 explorable atlas로 변환하며, 어떤 좌표도 풍부한 place, route, story로 확장될 수 있다. Galaxy Travel과 같은 fictional-universe demo는 procedural galaxy를 생성하며, 대규모 구조는 code에 의해 지배되고 language model은 mission, character, educational content를 제공한다. 다른 demo들은 open web을 browsable 환경으로 wrapping하거나, long-form book을 navigable narrative world로 reinterpret한다. 우리는 또한 language model을 rule과 content generator로 취급하면서 core transition을 deterministic하게 유지하는 alchemy-style combinatorial system과 card-based roguelike를 포함한 simulation 및 game-like 환경을 구축한다. 이러한 demo들은 Web World Model abstraction이 특정 task나 genre에 묶여 있지 않음을 보여준다: 실제 또는 가상의, knowledge-centric 또는 interaction-driven, single-user 또는 multi-agent world를 호스팅할 수 있다.

이러한 예제들을 통해 우리는 Web World Model 구축을 위한 네 가지 핵심 design principle을 도출한다(Section 3). 첫째, Separation of Concerns: core rule과 state transition(Physics)은 creative generation(Imagination)과 구별되어야 한다. 둘째, Typed Interface: latent world state는 opaque embedding이 아닌 명시적이고 typed된 web interface(JSON schema)로 표현되어야 한다. 셋째, Infinite Worlds via Deterministic Generation: procedural expansion은 world가 action space를 폭발시키지 않고 성장할 수 있도록 고정된 schema를 준수해야 한다. 마지막으로, Graceful Degradation: procedural generator와 template을 결합하여 model call이 느리거나 사용할 수 없을 때도 world가 계속 사용 가능해야 한다.

요약하면, 본 논문은 code를 physics의 substrate로, language model을 bounded imagination engine으로 취급함으로써 web stack 자체가 world model을 호스팅할 수 있는 방법을 탐구한다. 우리의 주요 기여는 다음과 같다:

- 우리는 Web World Model의 개념을 정립하고 이를 fixed-context web framework와 fully generative world model 사이에 위치시키며, context capacity, controllability, environment type의 축을 따라 design space를 명확히 한다.
- 우리는 realistic web technology stack 위에서 real-world atlas, fictional galaxy, web-scale encyclopedia, interactive narrative, simulation, game을 포괄하는 일련의 Web World Model을 구현하여 abstraction의 일반성을 입증한다.
- 우리는 WWM 구축을 위한 실용적인 design insight, 즉 Separation of Concerns, Typed Interface, Deterministic Generation, Graceful Degradation을 도출하고, 이러한 insight가 향후 LLM-based 환경 및 agent 설계를 어떻게 안내하는지 논의한다.

## 2 Web World Model의 Design Principle

신뢰할 수 있는 environmental modeling은 deterministic logic과 probabilistic generation 사이의 시너지를 필요로 한다. 순수 generative model은 hallucination과 state inconsistency에 취약하고, 기존의 hard-coded 환경은 semantic flexibility와 open-endedness가 부족하다. Web World Model (WWM)은 hybrid architecture를 통해 이 격차를 메운다. 우리는 이 framework를 scalable deployment에 실용적으로 만드는 네 가지 핵심 principle을 설명한다.

## 2.1 Separation of Concerns: Physics vs. Imagination

비디오 게임에서 physics engine과 rendering pipeline의 구분과 유사하게, WWM은 world state $S_t$를 두 개의 orthogonal component로 분해한다: $S_t = (S^{\phi}_t, S^{\psi}_t)$. Physics Layer $(S^{\phi})$는 엄격하게 deterministic code에 의해 정의된다. 이는 inventory, coordinate, resource cap과 같은 invariant state data를 유지하고, 잠긴 문을 통한 이동이나 적자 자금 지출과 같은 logical consistency를 강제한다. Imagination Layer $(S^{\psi})$는 stochastic하고 model-defined이다. 환경 description, NPC dialogue, aesthetic style과 같은 high-dimensional perceptual content를 생성한다.

Figure 3 Web World Model Architecture: deterministic Code Layer (Physics)와 stochastic AI Layer (Imagination) 사이의 분리.

![Figure 3](images/figure_3.png)

State transition은 엄격한 순서로 발생한다. 먼저 code가 logical outcome을 계산한다:

$$S^{\phi}_{t+1} = f_{\text{code}}(S^{\phi}_t, a_t)$$

그 다음 large language model $\pi_\theta$가 이 updated symbolic state를 조건으로 perceptual layer를 synthesize한다:

$$S^{\psi}_{t+1} \sim \pi_\theta(\cdot \mid S^{\phi}_{t+1})$$

이 decomposition은 code를 통해 world의 logical consistency를 유지하면서 AI가 풍부하고 다양한 scene과 text를 생성할 수 있게 한다.

## 2.2 Common Language로서의 Typed Interface

기존 deep learning에서 latent state는 일반적으로 opaque한 high-dimensional vector로 표현된다. WWM에서 우리는 이 black-box representation을 Typed Interface로 대체한다. 우리는 code와 model 사이의 binding contract 역할을 하는 strict schema(예: interface Planet { biome: string; hazard: string; })를 정의한다.

LLM은 pixel이나 embedding을 predict하는 대신 이러한 type definition을 준수하는 valid JSON object를 predict한다. 이는 latent space를 transparent하고 debuggable한 data structure로 변환한다. 이는 imagined content가 engine의 logic과 structurally compatible하게 유지됨을 보장한다. model이 새로운 item을 생성하면 physics engine이 요구하는 특정 field(예: weight, cost)를 populate해야 한다. 따라서 typed interface는 syntactic filter로 작용하여 structural hallucination을 제거하고 model output이 application logic을 위반하는 것을 방지한다.

## 2.3 Deterministic Hashing을 통한 Infinite World

우리는 infinite universe를 database에 저장할 수 없다. 대신 procedural generation principle을 사용하여 'Just-In-Time'으로 생성한다.

Figure 4 Deterministic Generation: input(visit)이 coordinate에 수렴하고, hash function을 거쳐 frozen seed를 생성한다. 이는 LLM이 매번 같은 world state를 output하도록 강제한다.

![Figure 4](images/figure_4.png)

사용자가 location $x$에 도착한다. 시스템은 database lookup을 건너뛴다. 우리는 coordinate를 hash function에 통과시켜 seed $h(x)$를 얻는다. seed는 LLM의 sampling randomness를 고정한다. player는 planet을 떠났다가 나중에 돌아와도 planet은 동일하게 유지된다. 이는 storage 비용 없이 Object Permanence를 제공한다:

$$S^{\psi}_t \equiv S^{\psi}_{t+k} \quad \text{if} \quad \text{location}(t) = \text{location}(t+k) \tag{2.1}$$

## 2.4 Graceful Degradation

모든 frame에 대해 LLM을 호출하는 것은 computationally prohibitive하다. WWM은 resource constraint에 적응하기 위해 Fidelity Slider를 사용한다. High Fidelity에서는 LLM이 실시간으로 bespoke content를 생성한다. latency constraint 하에서 시스템은 Medium Fidelity로 degrade하여 cached content를 retrieve한다. 최악의 시나리오에서는 Base Fidelity로 fallback하여 deterministic code가 pre-authored template을 활용한다.

code가 Physics $(S^{\phi})$를 govern하기 때문에 Imagination $(S^{\psi})$ layer가 unavailable해도 application은 functional하게 유지된다. 환경은 semantic richness를 잃을 수 있지만 logical continuity는 보존된다.

## 2.5 Technical Stack

현대 web stack은 WWM을 위한 이상적인 substrate를 제공한다. TypeScript는 neuro-symbolic contract에 필요한 type safety를 제공하고; HTTP streaming은 real-time text delivery를 허용하며; serverless architecture는 persistent infrastructure 관리 없이 procedurally generated world의 infinite scaling을 가능하게 한다.

## 3 예제

Web World Model framework의 다양성을 입증하기 위해 우리는 faithful geographic simulation에서 open-ended fictional narrative 및 logic-driven game에 이르는 다양한 domain을 포괄하는 application suite를 개발했다. 각 예제는 Section 2의 design principle을 구체적으로 instantiate한다: physics와 imagination의 분리, state를 위한 typed interface 사용, scalability를 위한 deterministic generation 활용.

## 3.1 Infinite Travel Atlas

Figure 5 Infinite Travel Atlas interaction flow. (a) 사용자가 reactive globe에서 geographic coordinate를 선택한다. (b) 이 input은 hash되어 deterministic seed와 location metadata를 retrieve하고, request를 Physics layer $(S^{\phi})$에 grounding한다. (c) Agent가 이 context를 받아 LLM(Imagination layer $S^{\psi}$)을 trigger하여 structured destination guide를 생성하고, visual theme과 itinerary detail을 결정한다. (d) 결과 content가 client에서 render되어 backend storage 없이 cohesive하고 persistent한 experience를 제공한다.

![Figure 5](images/figure_5.png)

Web World Model의 실용적 능력을 검증하기 위해 우리는 유명한 Google Earth 프로젝트에서 영감을 받은 high-fidelity interactive ecosystem-based Infinite Travel Atlas를 만들었다. 우리의 목표는 제한된 stored database backend에 의존하지 않고 실행될 수 있는 infinite state space를 가진 open exploration experience를 구축하는 것이다. 우리는 web-based simulator가 travel plan의 세부 사항에 어떻게 반응하고 LLM과 함께 globe와 상호작용하며 탐색하도록 사용자를 안내할 수 있는지 시연한다. 이 구현이 infinite state space를 관리하고 모든 geographic coordinate가 accessible하게 유지됨을 보장할 수 있음을 발견했다.

**Environment.** simulation 환경은 client-side TypeScript (JavaScript) application이며 CSS와 HTML로 스타일링된다. static map과 달리 이 interface는 사용자가 어디든 이동할 수 있는 continuously navigated map이다. 우리는 lightspot이 LLM API로부터 semantic context를 결정하도록 설계했다. globe는 사용자가 zoom in하거나 관심 영역 위로 cursor를 이동할 때 추가 정보가 render되어 해당 영역의 특성과 travel detail에 관한 더 포괄적인 이해를 용이하게 한다. 우리는 모든 interaction의 설계가 world의 realistic depiction에 기반하여 환경이 global과 각 node의 specific detail 사이에 connection을 establish할 수 있도록 보장한다.

**Neural-symbolic Web World Model.** Figure 5에서 보듯이 시스템은 Web World Model을 latent state가 interpretable하고 executable한 TypeScript module로 구성된 hybrid simulator로 만든다. 이 architecture에서 code는 aesthetic theme을 선택하기 전에 physical attribute를 infer하여 semantic grounding을 구축한다. LLM policy는 이후 이 structured latent space 내에서 visual overview 작성과 같은 high-level creative task를 수행한다. theme 선택 과정은 creativity를 보여준다. 먼저 시스템은 deterministic code에 기반하여 유효한 theme subset을 계산한다. 그 다음 LLM이 content generation을 guide할 특정 direction을 선택한다. 이러한 governing rule이 executable code로 존재하기 때문에 thematic inventory를 변경하면 model retraining 없이 즉시 world의 law가 reshape된다.

**Agents.** 우리의 primary objective는 사용자가 navigable 환경을 유지하면서 임의의 global coordinate를 선택할 수 있도록 infinite exploration을 용이하게 하는 것이다. 우리는 two-stage procedural generation strategy를 통해 이를 달성한다. 먼저 worldPromptService.ts가 query template으로 experience를 initialize한다. 둘째, proceduralBeaconService.ts가 사용자 interaction 시 stable identifier와 metadata를 가진 beacon을 deterministically 생성한다. 이는 destination이 finite database에 제약되지 않음을 보장한다. 대신 시스템은 consistent latent state를 JIT (Just-In-Time)으로 synthesize한다. LLM은 beacon의 metadata를 structured input으로 consume하여 destination guide를 생성한다. 이 architecture는 symbolic code가 geographic continuity와 interface stability를 보존하면서 agent가 rich하고 creative한 content를 제공할 수 있게 한다.

**Demonstrations.** 경험적 관찰은 시스템이 다양한 location에서 thematic consistency를 유지함을 확인한다(Figure 21). Nairobi 근처의 beacon을 선택하면 'desertbloom' theme이 올바르게 trigger되며, LLM은 outdoor trail과 history를 균형 있게 조화시킨 itinerary를 생성한다. 반대로 Honolulu(Figure 22)와 Rio de Janeiro(Figure 23) 같은 location은 structural interface fidelity를 유지하면서 지리에 맞는 distinct thematic response를 evoke한다. 이러한 예제들은 WWM이 standard web data를 controllable하고 infinite한 환경으로 변환할 수 있음을 보여준다. 이 abstraction의 boundary를 더 테스트하기 위해 다음으로 이 neural-symbolic design이 purely fictional universe를 지원할 수 있는지 조사한다.

## 3.2 Galaxy Travel Atlas

Figure 6 Galaxy Travel Atlas system architecture. Navigation event가 coordinate hash가 local star system layout(Physics)을 seed하는 procedural generation sequence를 trigger한다. Agent가 이 immutable structural state를 retrieve하고 LLM을 query하여 strictly typed JSON schema를 준수하는 narrative element, mission brief, hazard, lore를 synthesize한다. 이는 universe가 infinite하면서도 모든 planet이 revisited되고 logically consistent하게 유지됨을 보장한다.

![Figure 6](images/figure_6.png)

Infinite Travel Atlas를 기반으로 우리는 Galaxy Travel Atlas를 개발했다. Earth atlas가 real-world geography를 활용하는 반면, 이 application은 모든 content가 synthesize되는 procedural sci-fi simulation을 나타낸다. 사용자는 swirling galaxy의 universe를 navigate하며 cluster parameter를 조정하고 planet을 선택하여 mission brief에 접근한다. 시스템은 LLM을 활용하여 terrain, sky, signal, hazard를 describe하는 field log와 narrative hook을 생성한다. 이 demonstration은 WWM이 logically structured하고 infinite한 fictional universe를 지원할 수 있는 능력을 검증하는 것을 목표로 한다.

**Environment.** 시스템은 TypeScript stack 위에 구현된다. view는 galaxy layout, star lane, planet cluster를 procedurally 생성하는 universe.ts에 의해 driven된다. Generator parameter(예: planet density)가 사용자에게 노출되어 clickable world의 dense set을 보장한다. reseeding mechanism은 사용자가 generator를 advance할 수 있게 하여 reachable galaxy의 수를 effectively unbounded하게 render한다.

**Neural-symbolic Web World Model.** 우리의 design principle(Fig. 3)에 따라 Galaxy Travel Atlas는 world state를 deterministic physics layer와 stochastic imagination layer, $S_t = (S^{\phi}_t, S^{\psi}_t)$로 명시적으로 분리한다. 결정적으로 universe의 structural skeleton은 hallucinate되지 않는다; 계산된다. Physics Layer $(S^{\phi})$가 primary architect로 기능하며, procedural noise function(예: universe.ts의)을 활용하여 galaxy layout, star lane connectivity, planetary resource distribution을 dictate한다. 각 planet에는 stable identifier와 purely code에서 derived된 rigid symbolic attribute set—sector label, physical type, risk profile—이 할당된다. Object permanence는 hashing(Fig. 4)을 통해 달성되어 coordinate $(x, y)$를 revisit하면 database lookup 없이 항상 같은 physical state를 yield한다.

AI는 엄격히 Imagination Layer $(S^{\psi})$에 제한되어 이 rigid geometry에 narrative flavor text를 texture하기 위해서만 invoke된다. 그때도 model은 strict TypeScript interface(예: `interface Planet`)에 의해 constrain된다; code-defined biome과 hazard type에 match하는 valid JSON을 output해야 한다. model이 fail하거나 unreachable하면 시스템은 template-based description으로 gracefully degrade하여 world의 existence가 generative model과 independent함을 증명한다.

**Agents.** agent architecture는 autonomous reasoning보다 engineering robustness를 우선시한다. Agent는 deterministic seed와 metadata를 renderable JSON으로 변환하는 stateless transformation pipeline으로 기능한다. AgentPlugin interface를 통해 strict schema contract를 enforce함으로써 generated content—mission brief나 dialogue—가 hard-coded data와 structurally indistinguishable함을 보장한다.

이 design은 backend가 LLM을 just another microservice로 취급할 수 있게 한다. provider key가 configure되면 pipeline이 world를 bespoke text로 hydrate하고; 그렇지 않으면 static generator로 fall back한다. Persistence는 procedural seed로 keyed된 file-backed cache를 통해 handle되어 inference cost를 minimize한다. 따라서 agent의 'intelligence'는 safe하고 verifiable한 sandbox 내에 contain되어 model이 galaxy의 fundamental rule이나 geometry를 alter하는 것을 방지한다.

**Demonstrations.** 우리는 Figure 25에서 34까지 generated universe의 visual traversal을 제시한다. 이러한 snapshot들은 시스템이 diverse semantic content를 generate하면서 structural invariant를 유지하는 능력을 보여준다. 예를 들어 Velis Minor Node(Figure 27)를 선택하면 crystalline hazard와 specific signal pattern을 특징으로 하는 'stormglass' biome이 instantiate된다. 반대로 Threx Drift Node(Figure 29)는 different risk profile과 narrative hook을 가진 scrap-yard metropolis로 resolve된다. 추가 exploration은 Yaka Outpost(Figure 30)와 Halo Corridor Anchor(Figure 34) 같은 location을 reveal하며, 이들은 different procedural seed에서 originate했음에도 같은 strictly typed interface를 adhere한다. 이러한 illustration들은 Web World Model이 effectively unbounded fictional state space를 지원할 수 있음을 확인하며, deterministic code layer가 navigational continuity를 enforce하고 language model이 world를 coherent하고 context-aware한 detail로 populate한다.

## 3.3 AI Spire라는 Card Game

Figure 7 AI Spire의 Neural-symbolic architecture. Client-side TypeScript/React combat engine이 player/enemy state(HP, energy, deck/hand, status effect, enemy intent)를 maintain한다; combat이 won되면 reward phase가 standard reward(three generated card) 또는 custom card를 위한 user-specified 'Wish'를 trigger한다. 두 경우 모두 Gemini Flash가 constrained designer로 작용하여 schema-structured JSON specification(name, description, effect code)을 return하며, 이는 TypeScript interface(ICard / IRelic)를 통해 shared되는 contract-and-validation layer에 의해 check된다. 그 다음 symbolic core가 effect code를 deterministic rule execution으로 translate하고 deck/relic inventory를 update하여 다음 encounter를 위한 loop를 close한다.

![Figure 7](resources/figure_7.jpeg)

**Environment.** 시스템의 client-side는 TypeScript/React 19이며 Google GenAI SDK에 의해 driven되고 Tailwind CSS로 스타일링된다. 시스템은 reward picking(card와 relic 포함)을 위한 backend database가 없으며, 대신 reward content는 user의 request로부터 generate되고 renderer의 expected typed interface를 meet해야 한다. 예를 들어 services/geminiService.ts 아래의 prompt와 JSON schema가 reward generation을 control하고 App.tsx에 의해 maintain되는 core engine state(player, enemy, deck/discard, round turning)가 있다. generating과 executing process는 TypeScript(ICard와 IRelic)를 share하고 runtime error를 reduce하기 위한 explicit contract를 형성한다.

**Neural-symbolic Web World Model.** AI Spire는 creative generation과 executable mechanic을 분리했다. neural component(Gemini Flash)는 restricted designer로 작용한다: user가 원하는 card power와 mechanic의 prompt와 description을 받아 name, card description text, effect code를 가진 JSON object를 return한다. App.tsx의 symbolic component는 rule engine으로 작용한다: 이러한 effect code를 translate하고 game status에 적용한다. 예를 들어 어떤 relic이 start combat strength 1 같은 effect를 contain하면 trigger handler가

Figure 8 AI Spire reward page의 User interface. elite combat을 이기고 나면 LLM에 의해 extra lyrics reward가 generate된다(red box). 세 개의 common card가 LLM에 의해 generate되어 user에게 제공된다(blue box). common reward 외에도 user는 'wish'(green box)를 설정하여 reward card를 customize할 수 있다. 예를 들어 'a card that could deal a huge amount of burn to the enemy.'를 typing하면 neural-symbolic core가 user의 request에 기반하여 card를 generate한다(orange box에 표시). User는 classical Slay the Spire-like game처럼 reward를 skip(purple box)할 수도 있다.

![Figure 8](resources/figure_8.jpeg)

related event를 detect하고 combat 시작 시 user의 strength variable을 increase한다. 이런 종류의 separation은 safe creativity를 실현한다: model은 새로운 것을 generate할 수 있지만 effect는 code implementation을 위한 controlled vocabulary로 restrict된다.

**Procedural content와 The Wish.** Standard reward는 LLM 사용과 함께 geminiService.ts 아래의 generateRewardCards에 의해 generate된다. 게임은 또한 The Wish mechanism을 포함하여 user가 'a fireball that could deal a large amount of burn but also freeze the enemy' 같은 free-form prompt로 card를 request할 수 있다. generateWishCard service가 user prompt를 effective mechanic으로 translate한다. 이 예제에서는 high burn(LLM-generated reasonable value와 함께)을 deal하고 enemy에게 freezing status도 apply한다. shop scene에서도 유사한 procedure가 작동한다; player가 shop에 enter하면 current run state에 기반한 price와 rarity constraint를 가진 themed inventory의 generation을 trigger한다.

**Robustness와 fallback.** generation과 execution 사이의 interface는 schema validation에 의해 guard된다. geminiService.ts 아래에서 GenAI responseSchema가 expectation을 meet하도록 structure를 shape(CARD SCHEMA와 RELIC SCHEMA 같은)하고, integer cost와 valid card type(ATTACK, SKILL, POWER)을 restrict한다. valid API key가 missing하거나 API call이 fail하면 시스템은 stored sample을 call하여 gameplay가 여전히 smooth하게 유지된다.

**Demonstrations.** 일반적인 gameplay 중 user는 common/elite나 boss 같은 다른 종류의 enemy를 만날 수 있다; game engine이 HP,

Figure 9 AI Alchemy의 Neural-symbolic architecture. React+Canvas user interface(toolbar와 natural-language Creator Console)가 user-defined material을 symbolic cellular-automata 'falling-sand' simulator에 inject한다. particle collision 시 engine은 available한 existing reaction rule을 apply하고; 그렇지 않으면 LLM(Gemini Flash)을 query하여 schema-constrained reaction outcome을 synthesize하며, 이는 cache되어 즉시 update loop에 integrate된다. optional AI Supervisor가 canvas를 monitor하고 system을 guide/perturb하여 self-expanding sandbox에서 controlled emergent behavior를 enable한다.

![Figure 9](images/figure_9.png)

block, status effect, deck cycling 같은 bookkeeping을 담당한다. combat을 이기고 나면 reward section이 3개의 real-time-generated card와 user가 새 card를 위한 'wish'를 type할 box를 제공한다. user는 더 많은 resource를 gather하기 위해 'Echoing Blade' 같은 제공된 3개의 card 중 reward를 choose할 수 있으며, 이는 '7 damage를 deal하고 discard pile에서 ATTACK card도 recover'하거나, 'a card that will heal myself and restore energy'를 typing하여 자신의 reward를 customize할 수 있어 generated card를 play할 때 HP를 gain할 수 있다.

## 3.4 AI Alchemy라는 Sandbox

AI Alchemy는 WWM을 cellular automata 분야에 적용하여 'falling sand' simulation genre를 redefine한다. 전통적인 sandbox는 고정된 reaction table(예: water+fire=steam)에 의존하여 discoverability를 developer preset으로 limit한다. AI Alchemy에서는 reaction과 material이 open-ended이다: user가 새로운 material이나 combination을 introduce할 때 LLM이 physical constraint 하에서 valid reaction과 result를 propose한다. 이 시스템은 real-time generation을 활용하여 simulation ecosystem을 autonomously expand한다.

**Environment와 interaction.** interface는 React 19와 HTML Canvas grid를 활용하여 gravity, flow, diffusion 같은 physics를 simulate한다. user는 toolbar에서 primary element(Water, Fire, Sand)를 select하거나 Creator Console을 사용하여 natural language로 새로운 element를 define한다. 시스템은 이러한 prompt를 structured하고 physically-defined된 element(color, state, decay, interaction rule을 가진)로 translate한다. optional AI Supervisor는 autonomous agent로 작용하여 canvas state를 monitor하고 system을 perturb하여 emergent behavior를 induce한다.

**Neural-symbolic Web World Model.** symbolic core(sandbox.tsx)는 cellular automation을 수행하며 POWDER, LIQUID, GAS 등의 physical category에 의존하여

Figure 10 AI Alchemy의 User interface. upper-left panel(blue box)은 creator console을 보여주며 user가 natural language로 원하는 rule을 가진 새로운 element를 introduce할 수 있다. lower-left panel(orange box)은 element bar를 보여주며 현재 available한 element를 display한다. top overlay(green box)는 AI supervisor layer를 indicate하며 LLM이 gameplay에 introduce되는지 toggling한다. central canvas(purple box)는 simulation canvas를 represent하며 모든 automata의 behavior가 일어난다. right panel(red)은 Alchemist log를 display하며 LLM-generated element와 corresponding reaction을 record한다.

![Figure 10](images/figure_10.png)

particle을 update한다. reaction은 reactionCache/pendingResolution에 의해 guide된다: 두 element가 collide할 때 engine은 먼저 reaction을 위한 existing rule이 있는지 check한다. 없으면 시스템은 LLM을 call하고 related element type에 의해 reaction을 judge한 다음 reaction outcome(Ash, Steam 등)을 produce하고 simulator를 위한 constrained parameter를 제공한다. reaction result는 cache되어 즉시 automata mechanism에 integrate된다. Safety와 stability는 schema level에서 enforce된다: generation은 새로운 concept을 produce할 수 있지만 simulator는 전체 simulation을 under control하게 만들기 위해 rate limit(decay probability, energy use 등)을 restrict한다.

**Demonstrations.** preset reaction table을 real-time rule generation으로 replace한 후 시스템은 emergent behavior를 위한 더 큰 space를 얻는다: gameplay 중 시스템 자체가 Life+Fire=Ash, Ash+water=Nutrient mud, nutrient mud+Life=more Life 같은 rule을 explore할 수 있다. nano-robot의 transport dynamics와 heater 및 fan 같은 machine-like element처럼 더 complex한 behavior도 시스템에서 simulate될 수 있다. AI supervisor는 global statistics를 monitor하여 single element가 world를 dominate하는 것을 avoid한 다음 rainfall로 system에 water를 induce하거나 burning으로 dominated Life나 element를 destroy하거나 그냥 직접 void로 보낼 수 있다. 결국 우리는 physically explainable하면서도 constrained generation을 가진 self-expanding system인 sandbox system을 얻는다.

Figure 11 Cosmic Voyager의 Neural-symbolic architecture. browser-based user interface(orbit view, piloted flight, surface walk를 위한 mode selection과 planet selection 및 camera control)가 scene/state, procedural asset, navigation logic, rendering을 manage하는 WebGL solar-system engine을 drive한다. engine은 currently selected celestial body와 view context를 symbolic core(Gemini Flash)에 stream하고, 이는 (i) short general sidebar description과 (ii) 30초마다 typewriter reveal로 bottom subtitle로 refresh되는 view-dependent 'Cosmic Guide' narration을 generate한다. API가 unavailable할 때 시스템은 bundled description으로 fall back하여 continuous educational experience를 preserve한다.

![Figure 11](resources/figure_11.jpeg)

## 3.5 Cosmic Voyager

Cosmic Voyager는 planetary exploration을 위한 3D Web World Model을 implement한다. pre-rendered media에 의존하는 대신 spatial context가 agent explanation을 dictate하는 navigable solar system을 제공한다. experience는 lightweight spaceflight simulator로 기능한다: user는 orbit viewing, piloted flight, surface walking 사이를 switch하고 AI guide는 current viewpoint에 match하는 educational narration을 generate한다.

**Environment.** Cosmic Voyager는 WebGL을 사용하여 stylized solar system을 render한다. user는 여러 interaction mode 사이를 switch할 수 있다: high-level orbital overview, ship-like control scheme(piloted flight), 그리고 generated terrain에서의 surface exploration. bottom 'Cosmic Guide' subtitle strip은 30초마다 auto-refresh되며 currently viewed body나 context를 narrate한다.

**Neural-symbolic Web World Model.** Scene layout과 motion은 physical fidelity보다 clarity를 위해 scripted된다: preset orbital speed, static distance, rim-glow atmosphere, optional ring, procedural asteroid placement. currently selected body의 name이 주어지면 Gemini call이 short general description을 return한다(API fail 시 baked-in fallback 포함). general description 외에도 view-aware Cosmic Guide subtitle이 currently selected body와 camera context에 tailored된 Gemini narration으로 30초마다 update된다.

Figure 12 Cosmic Voyager의 User interface(왼쪽에서 오른쪽). Orbit Mode(blue box로 circled)는 selectable body를 가진 high-level solar-system overview를 present한다; object(예: Sun)를 choose하면 key stat과 AI-generated quick summary를 가진 sidebar card(orange box로 circled)가 열린다. Pilot Mode는 system을 통한 navigable traversal을 위해 ship-like free-flight camera로 switch한다. Surface Walk는 landing 후 generated planetary surface에서 first-person exploration을 enable한다. 모든 mode에 걸쳐 persistent bottom 'Cosmic Guide'(green box로 circled) subtitle strip이 currently selected body와 camera context에 tied된 view-dependent narration으로 30초마다 refresh된다.

![Figure 12](resources/figure_12.jpeg)

**Current capability와 future extension.** 포함된 content는 Sun, major planet, 주요 moon, playful claimed asteroid를 span한다. control은 orbiting, free flight, scaled sphere 위에서의 pointer-locked walking을 support한다; scale은 usability를 위해 intentionally compressed된다. Live Gemini narration은 GEMINI API KEY를 supply하는 것에 depend하며, 없으면 app은 bundled description으로 fall back한다. potential extension은 richer surface variation, more realistic orbital mechanics, VR, shared multiuser tour를 include한다.

**Demonstrations.** session은 orbital overview에서 열린다; Jupiter를 select하면 smooth camera travel이 trigger되고 sidebar에 AI blurb가 surface된다. asteroid belt를 click하면 nearby rock에 focus가 snap되고 owner와 mining information이 표시된다. Mars에 land를 choose하면 spherical surface에서 first-person view로 switch되며 Sun과 other planet이 sky에 visible하고 movement는 player 아래의 world를 rotate하여 simulate된다.

## 3.6 WWMPedia

WWMPedia는 우리의 knowledge-centric Web World Model이다: pre-indexed corpus를 navigate하는 대신 user가 natural-language query를 통해 enter하고 시스템이 Wikipedia-like page를 on the fly로 synthesize한다(Grokpedia와 유사). 개념적으로 world는 open web이며 각 generated page는 이 world를 legible하고 browsable하게 만드는 local 'state'이다.

**Environment.** WWMPedia의 environment는 small set의 browser primitive를 통해 expose되는 live web이다: (i) query search, (ii) candidate page open, (iii) text span을 evidence로 extract. 이 environment는 topic space에서 effectively unbounded하고 실제로는 partially observable하다:

![Figure 13](resources/figure_13.jpeg)

**(a)** Superconductor를 위한 Wikipedia entry. **(b)** Grokipedia는 predefined article에서 select해야 한다. **(c)** 같은 query에 대해 on-demand로 generate된 WWMPedia page.

**Figure 13** 'Superconductor' query에 대한 Wikipedia vs. Grokipedia vs. WWMPedia. WWMPedia는 open web을 unbounded knowledge world로 treat한다: agent가 search와 page opening을 통해 evidence를 retrieve하고(Physics, $S^{\phi}$), LLM이 retrieved source에 대한 citation이 annotate된 table of contents와 sectioned prose를 가진 structured article view(Imagination, $S^{\psi}$)를 compose한다. 또한 user는 'explain more' button을 click하여 어떤 section이든 elaborate하도록 choose할 수 있다.

agent는 retrieve하기로 choose한 것만 보며, different query는 web의 different neighborhood를 surface한다.

**WWM instantiation.** WWMPedia는 WWM split $S_t = (S^{\phi}_t, S^{\psi}_t)$의 lightweight instantiation이다. Physics layer $S^{\phi}$는 ordinary web scaffolding으로 implement된다: query routing, retrieval, sanitization, 그리고 fixed page layout(title, table of contents, section, reference)을 enforce하는 deterministic HTML renderer. Imagination layer $S^{\psi}$는 LLM에 의해 produce된다: retrieved evidence bundle이 주어지면 outline을 select하고, sectioned exposition을 write하고, generated statement를 source에 link하는 reference list를 emit한다. UI는 이 provenance를 explicitly surface한다(예: Figure 13c의 'LLM generated'와 generation timestamp), 이는 page를 simple chat response보다 stateful artifact처럼 느끼게 만든다.

**왜 이것이 WWM인가.** WWM 관점에서 key design choice는 retrieval과 rendering이 code-defined라는 것이다. model은 web code에 의해 defined된 structured interface 내에서 operate하고, 그 output은 stable하고 inspectable한 page로 shape된다. user가 dropdown menu에서 predefined entry를 choose해야 하는 Grokipedia와 비교하여, 우리의 WWMPedia는 이 restriction을 remove하고 모든 것을 on the fly로 generate한다. 각 section도 고정되지 않으며 user의 request에 따라 further elaborate될 수 있다.

## 3.7 Bookshelf

Bookshelf는 다른 regime에서 WWM을 explore한다: long-form generative fiction. user interaction loop는 의도적으로 minimal하지만(book select, 그 다음 page turn), 시스템은 여전히 continuity를 maintain하고, style을 constrain하고, content를 stable하고 readable한 interface에 present해야 한다.

**Interface와 interaction.** entry screen(Figure 14a)은 compact control language로 기능하는 두 개의 orthogonal tag set을 expose한다. Interface style은 UI skin(typography, spacing, palette)을 select하고 client의 deterministic CSS/theming choice로 implement된다. Literary tag는

![Figure 14](resources/figure_14.jpeg)

**(a)** Library view. user는 UI skin(interface style)과 literary tag를 pick한 다음 LLM-proposed book card에서 select한다. **(b)** Reading view. Page-turn action(Prev/Next)과 Extend가 active style constraint를 preserve하면서 새로운 text를 stream한다.

Figure 14 Bookshelf(Infinite Reader) interface. user는 compact typed control surface를 통해 generation을 control한다: interface-style tag가 UI를 deterministically theme하고, literary tag가 narrative의 genre, tone, pacing을 constrain한다.

narrative constraint(genre, tone, pacing)를 specify하고 proposed book card(title/tagline/blurb)와 subsequent page generation 모두를 condition한다. 'Refresh unlocked tags' mechanism은 shelf를 dynamic하게 느끼게 유지한다: 일부 tag는 anchor로 fixed하게 held할 수 있고, 다른 것은 user가 prompt를 author할 필요 없이 adjacent style을 explore하도록 rotate된다.

**Latent state와 generation loop.** 내부적으로 Bookshelf는 Physics layer가 spatial dynamics가 아닌 narrative mechanics인 straightforward WWM이다. Source code가 session state와 page-turn semantics를 define한다: page length limit, streaming boundary, UI component composition, 어떤 field가 turn 간에 carried forward되는지. 각 page-turn에서 시스템은 LLM에 (i) active tag constraint, (ii) compact story state, (iii) recent text의 short window를 prompt한다. LLM은 reading panel(Figure 14b)로 stream되는 continuation을 return한다.

**Controllability와 persistence.** Bookshelf는 WWM 전반에 나타나는 practical engineering constraint를 highlight한다: long-horizon generation은 대부분 state management problem이다. carried state를 typed하고 small하게 유지하는 것이 useful함을 발견했다. LLM은 local prose와 scene-level detail을 담당하고, code는 stylistic constraint, pagination, 시스템이 current open plot thread라고 믿는 것과 같은 invariant를 preserve한다. 이 split은 story world가 indefinitely expand해도 stable interaction contract를 제공한다.

## 4 관련 연구

persistent하고 intelligent한 환경의 개발은 world modeling, language agent architecture, neuro-symbolic reasoning의 advancement의 integration을 포함한다. 우리는 현재 문헌을 네 가지 주요 research stream으로 categorize한다: foundational world model, persistent agent environment, dynamic game generation, agent reasoning framework.

**World Model과 Web Architecture.** World Model의 현대적 개념은 2018년 Ha와 Schmidhuber [[6]](#ref-6)에 의해 소개되었으며, 그들은 agent가 recurrent neural network에 의해 generate된 dream environment 내에서 전적으로 policy evolution을 learn할 수 있음을 보여주었다. large language model(LLM)의 advent와 함께 최근 연구는 pre-trained transformer의 inherent knowledge를 world simulator로 활용하는 방향으로 shift했다. Gu et al. [[5]](#ref-5)는 LLM이 internet world model로 작용할 수 있는지 논의하고 *WebDreamer*를 propose했으며, 이는 LLM을 사용하여 execution 전에 candidate action outcome을 simulate하고 score하여 planning에 필요한 risky live exploration의 양을 reduce한다. 유사하게 Hao et al. [[7]](#ref-7)는 *Reasoning via Planning (RAP)*을 propose했으며, 이는 LLM이 world model과 reasoning agent로 동시에 작용할 수 있어 language의 latent space에서 Monte Carlo Tree Search를 run할 수 있다. 이러한 generative approach를 practical engineering과 bridging하는 것은 neural network 초기의 foundational idea에 draw한다: Schmidhuber [[16]](#ref-16)은 environment dynamics(future reinforcement 포함)의 recurrent model이 credit assignment를 위한 differentiable pathway를 provide하는 online method를 describe하고, 그러한 model이 future action sequence에 대한 planning도 support할 수 있는 방법을 논의한다. 이 line of work은 나중에 history compression을 통한 hierarchical temporal abstraction으로 expand되었으며, 이는 long-horizon sequence modeling을 위한 multi-timescale predictive representation을 learn한다 [[17]](#ref-17). 더 최근에 LeCun [[9]](#ref-9)은 autonomous intelligent system의 cornerstone으로 predictive world model을 advocate했으며, agent가 model-based reasoning과 planning을 facilitate하기 위해 world의 hierarchical latent model을 continually learn해야 한다고 argue한다. 구체적으로 LeCun의 predictive-world-model agenda는 abstract representation space에서 missing information을 predict하는 Joint-Embedding Predictive Architecture를 통해 instantiate되었다. 예를 들어 image를 위한 I-JEPA [[2]](#ref-2)와 video를 위한 V-JEPA [[4]](#ref-4). 병행하여 diffusion-based generator는 learned simulator로 가는 alternative route를 provide한다; diffusion transformer(DiT)는 high-fidelity visual generation에 사용되는 diffusion model을 위한 scalable backbone을 offer한다 [[15]](#ref-15).

**Persistent Agent Environment와 Social Simulacra.** long-term agent interaction을 support하는 environment를 creating하려면 robust memory와 social simulation capability가 필요하다. Park et al. [[14]](#ref-14)는 *Generative Agents* architecture를 pioneering했으며, 이는 memory stream과 reflection mechanism을 활용하여 sandbox environment에서 believable human behavior와 social emergence를 simulate한다. 이 work은 그들의 earlier exploration인 *Social Simulacra* [[13]](#ref-13)를 기반으로 하며, 이는 LLM을 사용하여 diverse simulated user persona로 populate함으로써 social computing system을 prototype했다. embodied agent의 domain에서 Wang et al. [[19]](#ref-19)는 Minecraft에서 executable code skill의 library를 curate하여 continuously learn하는 LLM-powered agent인 *Voyager*를 introduce하여 open-ended exploration을 enable했다. 동시에 Zhu et al. [[25]](#ref-25)는 hierarchical planning과 text-based knowledge retrieval을 employ하여 complex open world에서 long-horizon task를 handle하는 *Ghost in the Minecraft (GITM)*을 propose했다.

**Dynamic Game과 Neuro-Symbolic AI.** generative AI와 interactive fiction의 intersection은 state consistency와 novelty adaptation에서 unique challenge를 present한다. Li et al. [[10]](#ref-10)은 specialized distillation technique을 사용하여 open-ended interaction으로 character life를 simulate하는 generative infinite game인 *Unbounded*로 이 field의 boundary를 push했다. 그러한 open world의 consistency issue를 address하기 위해 neuro-symbolic approach가 traction을 gained했다. Balloch et al. [[3]](#ref-3)는 open-world novelty에 rapidly adapt하기 위해 symbolic graph를 leverage하는 neuro-symbolic world model을 propose했다. Ammanabrolu와 Riedl [[1]](#ref-1)의 earlier work은 text-adventure game에서 graph-based deep reinforcement learning의 efficacy를 demonstrate하며 state change를 track하기 위해 knowledge graph를 활용했다. 또한 Huang et al. [[8]](#ref-8)은 language model에서 actionable knowledge를 directly extract하여 interactive environment에서 embodied agent를 guide하는 zero-shot planner로서 LLM의 potential을 explore했다.

**Agent Reasoning, Learning, 그리고 Benchmark.** 이러한 environment에서 robust agent performance는 advanced reasoning과 evaluation framework에 rely한다. Yao et al. [[22]](#ref-22)는 task solving을 improve하기 위해 reasoning과 acting을 synergize하는 paradigm인 *ReAct*를 introduce했다. long-term adaptability를 enhance하기 위해 Shinn et al. [[18]](#ref-18)은 agent가 verbal reinforcement feedback으로부터 learn하도록 허용하는 *Reflexion*을 propose했고, Majumder et al. [[12]](#ref-12)는 interaction history로부터 causal model을 abstract하는 continually learning agent인 *CLIN*을 develop했다. 이러한 capability를 evaluate하려면 comprehensive benchmark가 필요하다: Zhou et al. [[24]](#ref-24)는 interactive scenario를 통해 social intelligence에 focus했고, Wu et al. [[20]](#ref-20)는 general intelligent capability를 test하기 위한 game suite를 provide했으며, Lin et al. [[11]](#ref-11)은 simulated society에서 planning과 tool-use를 evaluate하기 위한 open-source sandbox를 offer했다. 최근 visual-spatial benchmark는 multimodal model이 internal "local world model"을 build하는지 further probe하고, model이 downstream reasoning을 위해 cognitive map을 explicitly construct할 때 gain을 show한다 [[21]](#ref-21), [[23]](#ref-23).

## 5 결론

본 연구에서 우리는 fixed-context web framework와 unconstrained generative environment 사이의 dichotomy를 bridge하는 architectural paradigm인 Web World Model (WWM)을 introduce한다. state transition과 physical invariant를 govern하는 deterministic code를 large language model의 probabilistic creativity로부터 explicitly decouple함으로써 우리는 static database에 rely하지 않는 scalable하고 hallucination-free한 world로 가는 path를 demonstrate한다. 우리의 application suite는 standard web protocol이 typed latent interface 및 procedural hashing과 combine될 때 persistent하고 open-ended exploration을 위한 robust substrate로 기능함을 validate한다. 궁극적으로 WWM은 practical middle ground를 establish하여 developer가 language agent가 unlimited imagination을 위한 capacity를 retain하면서 structural certainty로 act할 수 있는 environment를 build할 수 있게 한다.

## 참고문헌

<a id="ref-1"></a>**[1]** Prithviraj Ammanabrolu and Mark Riedl. Playing text-adventure games with graph-based deep reinforcement learning. In *Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long and Short Papers)*, pages 3557-3565, 2019. [arXiv:1812.01628](https://arxiv.org/abs/1812.01628)

<a id="ref-2"></a>**[2]** Mahmoud Assran, Quentin Duval, Ishan Misra, Piotr Bojanowski, Pascal Vincent, Michael Rabbat, Yann LeCun, and Nicolas Ballas. Self-supervised learning from images with a joint-embedding predictive architecture. In *Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition*, pages 15619-15629, 2023. [arXiv:2301.08243](https://arxiv.org/abs/2301.08243)

<a id="ref-3"></a>**[3]** Jonathan Balloch, Zhiyu Lin, Robert Wright, Xiangyu Peng, Mustafa Hussain, Aarun Srinivas, Julia Kim, and Mark O. Riedl. Neuro-symbolic world models for adapting to open world novelty. *arXiv preprint arXiv:2301.06294*, 2023. [arXiv:2301.06294](https://arxiv.org/abs/2301.06294)

<a id="ref-4"></a>**[4]** Adrien Bardes, Quentin Garrido, Jean Ponce, Xinlei Chen, Michael Rabbat, Yann LeCun, Mahmoud Assran, and Nicolas Ballas. Revisiting feature prediction for learning visual representations from video, 2024. [arXiv:2404.08471](https://arxiv.org/abs/2404.08471)

<a id="ref-5"></a>**[5]** Yu Gu, Kai Zhang, Yuting Ning, Boyuan Zheng, Boyu Gou, Tianci Xue, Cheng Chang, Sanjari Srivastava, Yanan Xie, Peng Qi, et al. Is your LLM secretly a world model of the internet? Model-based planning for web agents. *arXiv preprint arXiv:2411.06559*, 2024. [arXiv:2411.06559](https://arxiv.org/abs/2411.06559)

<a id="ref-6"></a>**[6]** David Ha and Jürgen Schmidhuber. Recurrent world models facilitate policy evolution. *Advances in Neural Information Processing Systems*, 31, 2018. [NeurIPS](https://papers.nips.cc/paper/7512-recurrent-world-models-facilitate-policy-evolution)

<a id="ref-7"></a>**[7]** Shibo Hao, Yi Gu, Haodi Ma, Joshua Hong, Zhen Wang, Daisy Wang, and Zhiting Hu. Reasoning with language model is planning with world model. In *Proceedings of the 2023 Conference on Empirical Methods in Natural Language Processing*, pages 8154-8173, 2023. [arXiv:2305.14992](https://arxiv.org/abs/2305.14992)

<a id="ref-8"></a>**[8]** Wenlong Huang, Pieter Abbeel, Deepak Pathak, and Igor Mordatch. Language models as zero-shot planners: Extracting actionable knowledge for embodied agents. In *International Conference on Machine Learning*, pages 9118-9147. PMLR, 2022. [arXiv:2201.07207](https://arxiv.org/abs/2201.07207)

<a id="ref-9"></a>**[9]** Yann LeCun. A path towards autonomous machine intelligence version 0.9.2, 2022-06-27. *Open Review*, 62(1):1-62, 2022. [OpenReview](https://openreview.net/pdf?id=BZ5a1r-kVsf)

<a id="ref-10"></a>**[10]** Jialu Li, Yuanzhen Li, Neal Wadhwa, Yael Pritch, David E. Jacobs, Michael Rubinstein, Mohit Bansal, and Nataniel Ruiz. Unbounded: A generative infinite game of character life simulation. *arXiv preprint arXiv:2410.18975*, 2024. [arXiv:2410.18975](https://arxiv.org/abs/2410.18975)

<a id="ref-11"></a>**[11]** Jiaju Lin, Haoran Zhao, Aochi Zhang, Yiting Wu, Huqiuyue Ping, and Qin Chen. AgentSims: An open-source sandbox for large language model evaluation. *arXiv preprint arXiv:2308.04026*, 2023. [arXiv:2308.04026](https://arxiv.org/abs/2308.04026)

<a id="ref-12"></a>**[12]** Bodhisattwa Prasad Majumder, Bhavana Dalvi Mishra, Peter Jansen, Oyvind Tafjord, Niket Tandon, Li Zhang, Chris Callison-Burch, and Peter Clark. CLIN: A continually learning language agent for rapid task adaptation and generalization. *arXiv preprint arXiv:2310.10134*, 2023. [arXiv:2310.10134](https://arxiv.org/abs/2310.10134)

<a id="ref-13"></a>**[13]** Joon Sung Park, Lindsay Popowski, Carrie Cai, Meredith Ringel Morris, Percy Liang, and Michael S. Bernstein. Social simulacra: Creating populated prototypes for social computing systems. In *Proceedings of the 35th Annual ACM Symposium on User Interface Software and Technology*, pages 1-18, 2022. [arXiv:2208.04024](https://arxiv.org/abs/2208.04024)

<a id="ref-14"></a>**[14]** Joon Sung Park, Joseph O'Brien, Carrie Jun Cai, Meredith Ringel Morris, Percy Liang, and Michael S. Bernstein. Generative agents: Interactive simulacra of human behavior. In *Proceedings of the 36th Annual ACM Symposium on User Interface Software and Technology*, pages 1-22, 2023. [arXiv:2304.03442](https://arxiv.org/abs/2304.03442)

<a id="ref-15"></a>**[15]** William Peebles and Saining Xie. Scalable diffusion models with transformers. In *Proceedings of the IEEE/CVF International Conference on Computer Vision*, pages 4195-4205, 2023. [arXiv:2212.09748](https://arxiv.org/abs/2212.09748)

<a id="ref-16"></a>**[16]** Jürgen Schmidhuber. An on-line algorithm for dynamic reinforcement learning and planning in reactive environments. In *1990 IJCNN International Joint Conference on Neural Networks*, pages 253-258. IEEE, 1990. [DOI](https://doi.org/10.1109/IJCNN.1990.137723)

<a id="ref-17"></a>**[17]** Jürgen Schmidhuber. Learning complex, extended sequences using the principle of history compression. *Neural Computation*, 4(2):234-242, 1992. [DOI](https://doi.org/10.1162/neco.1992.4.2.234)

<a id="ref-18"></a>**[18]** Noah Shinn, Federico Cassano, Ashwin Gopinath, Karthik Narasimhan, and Shunyu Yao. Reflexion: Language agents with verbal reinforcement learning. *Advances in Neural Information Processing Systems*, 36:8634-8652, 2023. [arXiv:2303.11366](https://arxiv.org/abs/2303.11366)

<a id="ref-19"></a>**[19]** Guanzhi Wang, Yuqi Xie, Yunfan Jiang, Ajay Mandlekar, Chaowei Xiao, Yuke Zhu, Linxi Fan, and Anima Anandkumar. Voyager: An open-ended embodied agent with large language models. *arXiv preprint arXiv:2305.16291*, 2023. [arXiv:2305.16291](https://arxiv.org/abs/2305.16291) | [Project Page](https://voyager.minedojo.org/)

<a id="ref-20"></a>**[20]** Yue Wu, Xuan Tang, Tom M. Mitchell, and Yuanzhi Li. SmartPlay: A benchmark for LLMs as intelligent agents. *arXiv preprint arXiv:2310.01557*, 2023. [arXiv:2310.01557](https://arxiv.org/abs/2310.01557)

<a id="ref-21"></a>**[21]** Jihan Yang, Shusheng Yang, Anjali W. Gupta, Rilyn Han, Li Fei-Fei, and Saining Xie. Thinking in space: How multimodal large language models see, remember, and recall spaces. In *Proceedings of the Computer Vision and Pattern Recognition Conference*, pages 10632-10643, 2025. [arXiv:2412.14171](https://arxiv.org/abs/2412.14171)

<a id="ref-22"></a>**[22]** Shunyu Yao, Jeffrey Zhao, Dian Yu, Nan Du, Izhak Shafran, Karthik Narasimhan, and Yuan Cao. ReAct: Synergizing reasoning and acting in language models. In *International Conference on Learning Representations (ICLR)*, 2023. [arXiv:2210.03629](https://arxiv.org/abs/2210.03629)

<a id="ref-23"></a>**[23]** Baiqiao Yin, Qineng Wang, Pingyue Zhang, Jianshu Zhang, Kangrui Wang, Zihan Wang, Jieyu Zhang, Keshigeyan Chandrasegaran, Han Liu, Ranjay Krishna, et al. Spatial mental modeling from limited views. In *Structural Priors for Vision Workshop at ICCV'25*, 2025. [arXiv:2506.21458](https://arxiv.org/abs/2506.21458)

<a id="ref-24"></a>**[24]** Xuhui Zhou, Hao Zhu, Leena Mathur, Ruohong Zhang, Haofei Yu, Zhengyang Qi, Louis-Philippe Morency, Yonatan Bisk, Daniel Fried, Graham Neubig, et al. SOTOPIA: Interactive evaluation for social intelligence in language agents. *arXiv preprint arXiv:2310.11667*, 2023. [arXiv:2310.11667](https://arxiv.org/abs/2310.11667)

<a id="ref-25"></a>**[25]** Xizhou Zhu, Yuntao Chen, Hao Tian, Chenxin Tao, Weijie Su, Chenyu Yang, Gao Huang, Bin Li, Lewei Lu, Xiaogang Wang, et al. Ghost in the Minecraft: Generally capable agents for open-world environments via large language models with text-based knowledge and memory. *arXiv preprint arXiv:2305.17144*, 2023. [arXiv:2305.17144](https://arxiv.org/abs/2305.17144)

## Appendix A: 추가 예제

이 appendix는 구현된 Web World Model의 comprehensive visual gallery를 제공한다. *Infinite Travel Atlas*, *Galaxy Travel Atlas*, 그리고 본문에서 논의된 다른 demonstration의 UI state, generative diversity, interaction flow를 showcase한다.

Figure 15 Infinite Travel Atlas (a) 사용자가 빛나는 beacon 중 하나를 선택하도록 초대하는 empty cockpit과 함께하는 initial globe view.

![Figure 15](images/figure_15.png)

**Figure 16**: Infinite Travel Atlas (b) Innsbruck를 선택한 후 beacon이 light up되고 cockpit이 themed guide로 채워지기 시작한다.

![Figure 16](images/figure_16.png)

Figure 17 Infinite Travel Atlas (c) scrollable cockpit view로 render된 Innsbruck를 위한 full generated guide.

![Figure 17](images/figure_17.png)

**Figure 18** Infinite Travel Atlas (d) Innsbruck guide의 top section: visual overview와 이 여행이 특별하게 느껴지는 이유.

![Figure 18](images/figure_18.png)

Figure 19 Infinite Travel Atlas (e) Mid-section: morning/afternoon/evening card를 가진 3일간의 suggested rhythm.

![Figure 19](images/figure_19.png)

Figure 20 Infinite Travel Atlas (f) Bottom section: don't-miss moment, food, culture, practical tip, safety guidance.

![Figure 20](images/figure_20.png)

Figure 21 Infinite Travel Atlas (g) Nairobi, Kenya: panoramic lookout을 위한 warm desert-bloom theme과 amber cockpit.

![Figure 21](images/figure_21.png)

Figure 22 Infinite Travel Atlas (h) Honolulu, United States: old-town district를 위한 violet palette의 urban-pulse theme.

![Figure 22](images/figure_22.png)

Figure 23 Infinite Travel Atlas (i) Rio de Janeiro, Brazil: bay-overlook vantage point를 위한 blue cockpit의 coastal-drift theme.

![Figure 23](images/figure_23.png)

Figure 24 Infinite Travel Atlas (j) Los Angeles, United States: archaeological-site hop을 위한 compact globe framing과 atlas label.

![Figure 24](images/figure_24.png)

Figure 25 Galaxy Travel Atlas landing state. left map plane은 이미 procedurally generated cluster로 populate되었고, mission brief panel은 empty로 유지되며 사용자에게 planet을 select하여 log를 열도록 prompt한다.

![Figure 25](images/figure_25.png)

Figure 26 Atlas map plane close-up. 사용자가 planet density slider를 조정하여 galaxy control과 persistent node identifier를 통해 navigation을 stable하게 유지하면서 visible cluster(dense signal belt)를 reshape한다.

![Figure 26](images/figure_26.png)

Figure 27 Click-to-generate interaction. Velis Minor Node를 selecting하면 agent가 structured mission brief(terrain/sky/signal/hazard를 위한 profile card)와 narrative mission hook을 produce하도록 trigger하고, voyager thread가 multi-stop route를 summarize한다.

![Figure 27](images/figure_27.png)

Figure 28 새로운 galaxy view로 switching. 사용자가 다른 procedurally generated region(Cinder Array)으로 step하고 specific world를 selecting하기 전에 fresh하고 dense하며 clickable한 layout을 receive한다.

![Figure 28](images/figure_28.png)

Figure 29 world 간 theme과 content variation. Threx Drift Node를 choosing하면 different hazard list와 signal description을 가진 contrasting setting(scrapyard-metropolis flavor)이 yield되고, UI structure는 same하게 remain한다.

![Figure 29](images/figure_29.png)

Figure 30 different 'vibe'를 가진 another node selection. Yaka Outpost는 자체 terrain/sky/signal/hazards card와 새로운 mission hook을 가진 oceanic outpost scenario로 render되어 location-conditioned generation을 illustrate한다.

![Figure 30](images/figure_30.png)

Figure 31 Ringed gas-giant colony example. Arda Spire는 같은 atlas interaction pattern이 visually하고 narratively distinct한 world(예: ring structure, atmospheric hazard, different exploration prompt)를 어떻게 support하는지 demonstrate한다.

![Figure 31](images/figure_31.png)

Figure 32 Generation-in-progress ('syncing') state. Krypton Gate Node를 selecting한 후 mission panel이 agent가 brief를 prepare하는 동안 live calibration/loading phase에 enter하여 content generation 중에 interface를 responsive하게 keep한다.

![Figure 32](images/figure_32.png)

Figure 33 City-world mission brief. Halion Reach Node는 another distinct profile을 illustrate한다: different hazard와 separate mission hook을 가진 dense metropolitan terrain으로, repeatable structure with high-variance content를 showing한다.

![Figure 33](images/figure_33.png)

Figure 34 Anchor-type destination. Halo Corridor Anchor는 atlas가 non-planet node도 support함을 highlight하며, Voyager thread는 계속해서 world를 galaxy 전체에 걸친 longer exploratory route로 stitch한다.

![Figure 34](images/figure_34.png)

Figure 35 Cosmic Voyager: 사용자가 planet을 click하여 LLM(Gemini 2.5 flash)에 의해 generate된 description을 view할 수 있다. AI narration이 bottom에 subtitle로 appear하여 사용자의 view에 대한 description을 showing한다.

![Figure 35](images/figure_35.png)

Figure 36 Cosmic Voyager: demo는 사용자가 planet에 land하고 그 위를 walk할 수 있게 한다. terrain은 rock과 small mountain을 가진 LLM에 의해 generated된다. day/night light effect도 rock에 shadow를 cast한다. AI narration은 이 mode에서 persist한다.

![Figure 36](images/figure_36.png)

Figure 37 Cosmic Voyager: 사용자가 asteroid belt를 click하고 그 description을 볼 수 있다. description은 position에 based된 owner, mining data, size를 include한다.

![Figure 37](images/figure_37.png)
